apiVersion: automation.cloudbees.io/v1alpha1
kind: action
name: 'Register build artifact'
description: 'Creates an artifact version association with the workflow run.'

inputs:
  name:
    description: 'The name of the artifact.'
    required: true
  version:
    description: 'The version of the artifact.'
    required: true
  url:
    description: 'The url where the artifact version is located e.g. docker.io/myapp/myimg:1.0.0.'
    required: true
  digest:
    description: 'The artifact digest that uniquely and immutably identifies the artifact.'
  labels:
    description: 'List of comma-separated labels.'
  commit:
    description:
      The commit ID from the source repository, used when registering the build artifact in CloudBees Unify.
    default: ${{ cloudbees.scm.sha }}
  repository-url:
    description: >
      The clone URL of the source repository, used when registering the build artifact in CloudBees Unify.
    default: ${{ cloudbees.scm.repositoryUrl }}
  ref:
    description: >
      The tag or branch of the source repository, used when registering the build artifact in CloudBees Unify.
    default: ${{ cloudbees.scm.ref }}
  component-id:
    description: >
      The ID of the component associated with the artifact. If not provided, the artifact is registered with the component of the current workflow run.
    default: ${{ cloudbees.component.id }}
  type:
    description: 'The type of the artifact (e.g., docker, maven, npm). This field is for display purposes only.'

outputs:
  artifact-id:
    value: ${{ steps.set-artifact-id-output.outputs.artifact-id }}
    description: "The unique identifier of the artifact."

runs:
  using: composite
  steps:
    - id: prepare-payload
      name: Prepare Artifact Metadata Payload
      uses: docker://alpine:3.18
      run: |
        parse_labels_to_json() {
          input="$1"
          labels_json="["
          field=""
          in_quotes=0
          escape=0

          i=1
          len=${#input}

          add_field() {
            f=$1
            # Trim leading/trailing spaces
            f=$(echo "$f" | sed 's/^ *//;s/ *$//')
            # JSON-escape: backslash and quotes
            f=$(printf '%s' "$f" | sed 's/\\/\\\\/g; s/"/\\"/g')
            # Add to JSON array
            if [ "$labels_json" != "[" ]; then
              labels_json="$labels_json, "
            fi
            labels_json="$labels_json\"$f\""
          }

          while [ $i -le $len ]; do
            c=$(printf '%s' "$input" | cut -c $i)
            if [ "$escape" -eq 1 ]; then
              field="$field$c"
              escape=0
            elif [ "$c" = "\\" ]; then
              escape=1
            elif [ "$c" = '"' ]; then
              in_quotes=$((1-in_quotes))
              field="$field$c"
            elif [ "$c" = "," ] && [ "$in_quotes" -eq 0 ]; then
              add_field "$field"
              field=""
              # Skip spaces/tabs after comma
              while [ $i -lt $len ]; do
                n=$(printf '%s' "$input" | cut -c $((i+1)))
                  case "$n" in
                    " " | "	") i=$((i+1));;
                    *) break;;
                esac
              done
            else
              field="$field$c"
            fi

            i=$((i+1))
          done

          # Add the last field
          add_field "$field"

          labels_json="$labels_json]"
          # Final output
          echo "$labels_json"
        }
        
        # Create the JSON payload
        payload='[{ "name": "'"$INPUT_NAME"'", "url": "'"$INPUT_URL"'", "version": "'"$INPUT_VERSION"'"'
        
        # Add commit info if available
        if [ -n "$INPUT_COMMIT" ]; then
            payload="$payload, \"repositoryUrl\": \"$INPUT_REPOSITORY_URL\","
            payload="$payload \"commit\": \"$INPUT_COMMIT\","
            payload="$payload \"ref\": \"$INPUT_REF\""
        fi
        
        # Add digest if available
        if [ -n "$INPUT_DIGEST" ]; then
          payload="$payload, \"digest\": \"$INPUT_DIGEST\""
        fi
          
        # Add labels if available
        if [ -n "$INPUT_LABELS" ]; then
          escaped_labels=$(parse_labels_to_json "$INPUT_LABELS")
          payload="$payload, \"labels\": $escaped_labels"
        fi
          
        # Add componentId if available
        if [ -n "$INPUT_COMPONENT_ID" ]; then
          payload="$payload, \"componentId\": \"$INPUT_COMPONENT_ID\""
        fi
        
        # Add type if available
        if [ -n "$INPUT_TYPE" ]; then
          payload="$payload, \"type\": \"$INPUT_TYPE\""
        fi
          
        payload="$payload }]"
        
        # Store the final payload in output
        echo $payload > $CLOUDBEES_OUTPUTS/artifact-metadata

      env:
        JWT: ${{ cloudbees.api.token }}
        URL: ${{ cloudbees.api.url }}
        INPUT_NAME: ${{ inputs.name }}
        INPUT_VERSION: ${{ inputs.version }}
        INPUT_URL: ${{ inputs.url }}
        INPUT_DIGEST: ${{ inputs.digest }}
        INPUT_LABELS: ${{ inputs.labels }}
        INPUT_REPOSITORY_URL: ${{ inputs.repository-url }}
        INPUT_COMMIT: ${{ inputs.commit }}
        INPUT_REF: ${{ inputs.ref }}
        INPUT_COMPONENT_ID: ${{ inputs.component-id }}
        CLOUDBEES_RUN_ID: ${{ cloudbees.run_id }}
        CLOUDBEES_RUN_ATTEMPT: ${{ cloudbees.run_attempt }}
        INPUT_TYPE: ${{ inputs.type }}

    - id: register-build-artifact
      name: Register build artifact
      uses: cloudbees-io/register-build-artifacts@add-type-argument
      with:
        artifact-metadata: ${{ steps.prepare-payload.outputs.artifact-metadata }}

    - name: Set output parameter
      id: set-artifact-id-output
      uses: docker://esolang/jq:latest
      shell: sh
      run: |
        artifact_id=$(echo '${{ steps.register-build-artifact.outputs.artifact-ids }}' | /usr/bin/jq -r 'to_entries | .[0].value')
        echo $artifact_id > $CLOUDBEES_OUTPUTS/artifact-id
